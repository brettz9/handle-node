{"version":3,"file":"index-esm.min.js","sources":["../src/index.js"],"sourcesContent":["const nodeTypeToMethodMap = new Map([\n  [1, 'element'],\n  [2, 'attribute'],\n  [3, 'text'],\n  [4, 'cdata'],\n  [5, 'entityReference'],\n  [6, 'entity'],\n  [7, 'processingInstruction'],\n  [8, 'comment'],\n  [9, 'document'],\n  [10, 'documentType'],\n  [11, 'documentFragment'],\n  [12, 'notation']\n]);\n\n/**\n* Returns the value from executing a callback on a supplied callback\n*   object according to the type of node supplied.\n* @param {Node} node An XML or HTML node\n* @param {PlainObject} extraArgs Callback object whose propertiesâ€“all optional\n*   (`element`, `attribute`, `text`, `cdata`, `entityReference`, `entity`,\n*   `processingInstruction`, `comment`, `document`, `documentType`,\n*   `documentFragment`, `notation`) are callbacks which will be passed\n*   the supplied arguments\n* @returns {any|void} The result of calling the relevant callback\n*   (or `undefined` if no handler present)\n*/\nfunction handleNode (node, ...extraArgs) {\n  const cbObj = extraArgs[extraArgs.length - 1];\n\n  if (!nodeTypeToMethodMap.has(node.nodeType)) {\n    throw new TypeError('Not a valid `nodeType` value');\n  }\n  const methodName = nodeTypeToMethodMap.get(node.nodeType);\n  if (!cbObj[methodName]) {\n    return undefined;\n  }\n  return cbObj[methodName](node, ...extraArgs);\n}\n\nexport default handleNode;\n"],"names":["nodeTypeToMethodMap","Map","node","extraArgs","cbObj","length","has","nodeType","TypeError","methodName","get"],"mappings":"AAAA,IAAMA,EAAsB,IAAIC,IAAI,CAClC,CAAC,EAAG,WACJ,CAAC,EAAG,aACJ,CAAC,EAAG,QACJ,CAAC,EAAG,SACJ,CAAC,EAAG,mBACJ,CAAC,EAAG,UACJ,CAAC,EAAG,yBACJ,CAAC,EAAG,WACJ,CAAC,EAAG,YACJ,CAAC,GAAI,gBACL,CAAC,GAAI,oBACL,CAAC,GAAI,6BAeP,SAAqBC,8BAASC,mCAAAA,wBACtBC,EAAQD,EAAUA,EAAUE,OAAS,OAEtCL,EAAoBM,IAAIJ,EAAKK,gBAC1B,IAAIC,UAAU,oCAEhBC,EAAaT,EAAoBU,IAAIR,EAAKK,aAC3CH,EAAMK,UAGJL,EAAMK,SAANL,GAAkBF,UAASC"}